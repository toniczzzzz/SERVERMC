/**
 * Typings for Integrated Scripting.
 * This file is auto-generated on server start, so do not modify this file!
 */

declare global {
  var idContext: Context;
}

export interface Context {
  ops: Operations;
}

export interface Operations {
  entityItem: (arg0: ValueEntity) => ValueItemstack;
  fluidstackBucketFillSound: (arg0: ValueFluidstack) => string;
  operatorMap: (arg0: Function, arg1: any[]) => any[];
  itemstackIsFluidStack: (arg0: ValueItemstack) => boolean;
  anyLessThanOrEquals: (arg0: any, arg1: any) => boolean;
  nbtWithIntList: (arg0: Record<string, any>, arg1: string, arg2: any[]) => Record<string, any>;
  nbtWithInteger: (arg0: Record<string, any>, arg1: string, arg2: number) => Record<string, any>;
  booleanAsNbt: (arg0: boolean) => Record<string, any>;
  fluidstackIsRawEqual: (arg0: ValueFluidstack, arg1: ValueFluidstack) => boolean;
  listContains: (arg0: any[], arg1: any) => boolean;
  numberMin: (arg0: number, arg1: number) => number;
  nbtGetListTag: (arg0: Record<string, any>, arg1: string) => any[];
  entityEntityIsBurning: (arg0: ValueEntity) => boolean;
  itemstackIsFeContainer: (arg0: ValueItemstack) => boolean;
  longLongToInteger: (arg0: number) => number;
  entityType: (arg0: ValueEntity) => string;
  ingredientsWithItem: (arg0: ValueIngredients, arg1: number, arg2: ValueItemstack) => ValueIngredients;
  stringParseAsNbt: (arg0: string) => Record<string, any>;
  stringRegexGroups: (arg0: string, arg1: string) => any[];
  nbtType: (arg0: Record<string, any>, arg1: string) => string;
  doubleDoubleToLong: (arg0: number) => number;
  itemstackIsNbtEqual: (arg0: ValueItemstack, arg1: ValueItemstack) => boolean;
  entityDeathSound: (arg0: ValueEntity) => string;
  operatorNegation: (arg0: Function) => Function;
  listIntersection: (arg0: any[], arg1: any[]) => any[];
  operatorDisjunction: (arg0: Function, arg1: Function) => Function;
  entityHealth: (arg0: ValueEntity) => number;
  entityHeldItem: (arg0: ValueEntity) => ValueItemstack;
  fluidstackWithAmount: (arg0: ValueFluidstack, arg1: number) => ValueFluidstack;
  integerAsNbt: (arg0: number) => Record<string, any>;
  listTail: (arg0: any[]) => any[];
  blockBreakSound: (arg0: ValueBlock) => string;
  operatorReduce: (arg0: Function, arg1: any[], arg2: any) => any;
  ingredientsWithFluid: (arg0: ValueIngredients, arg1: number, arg2: ValueFluidstack) => ValueIngredients;
  blockTags: (arg0: ValueBlock) => any[];
  stringParseAsDouble: (arg0: string) => number;
  nbtWithFloat: (arg0: Record<string, any>, arg1: string, arg2: number) => Record<string, any>;
  numberModulus: (arg0: number, arg1: number) => number;
  entityWidth: (arg0: ValueEntity) => number;
  itemstackSize: (arg0: ValueItemstack) => number;
  entityIsAnimal: (arg0: ValueEntity) => boolean;
  stringAsNbt: (arg0: string) => Record<string, any>;
  integerLeftShift: (arg0: number, arg1: number) => number;
  anyIsNull: (arg0: any) => boolean;
  entityIsPlayer: (arg0: ValueEntity) => boolean;
  itemstackMod: (arg0: ValueItemstack) => string;
  fluidstackTemperature: (arg0: ValueFluidstack) => number;
  nbtWithTag: (arg0: Record<string, any>, arg1: string, arg2: Record<string, any>) => Record<string, any>;
  integerIntegerToLong: (arg0: number) => number;
  nbtMinus: (arg0: Record<string, any>, arg1: Record<string, any>) => Record<string, any>;
  entityEntityItemTooltip: (arg0: ValueEntity, arg1: ValueItemstack) => any[];
  nbtWithListLong: (arg0: Record<string, any>, arg1: string, arg2: any[]) => Record<string, any>;
  stringLength: (arg0: string) => number;
  stringItemsByTag: (arg0: string) => any[];
  operatorPipe2: (arg0: Function, arg1: Function, arg2: Function) => Function;
  nbtAsInt: (arg0: Record<string, any>) => number;
  itemstackCanHarvest: (arg0: ValueItemstack, arg1: ValueBlock) => boolean;
  listCount: (arg0: any[], arg1: any) => number;
  itemstackDataValue: (arg0: ValueItemstack, arg1: string) => Record<string, any>;
  booleanNand: (arg0: boolean, arg1: boolean) => boolean;
  entityArmorInventory: (arg0: ValueEntity) => any[];
  operatorPipe: (arg0: Function, arg1: Function) => Function;
  entityIsMinecart: (arg0: ValueEntity) => boolean;
  stringSplitOnRegex: (arg0: string, arg1: string) => any[];
  numberLessThan: (arg0: number, arg1: number) => boolean;
  integerComplement: (arg0: number) => number;
  itemstackBurnTime: (arg0: ValueItemstack) => number;
  listCountPredicate: (arg0: any[], arg1: Function) => number;
  entityIsMob: (arg0: ValueEntity) => boolean;
  nbtWithBoolean: (arg0: Record<string, any>, arg1: string, arg2: boolean) => Record<string, any>;
  entityEnergyCapacity: (arg0: ValueEntity) => number;
  nbtAsLong: (arg0: Record<string, any>) => number;
  listIsEmpty: (arg0: any[]) => boolean;
  itemstackDamage: (arg0: ValueItemstack) => number;
  numberRound: (arg0: number) => number;
  entityFluids: (arg0: ValueEntity) => any[];
  fluidstackIsLighterThanAir: (arg0: ValueFluidstack) => boolean;
  listEquals_set: (arg0: any[], arg1: any[]) => boolean;
  entityMounted: (arg0: ValueEntity) => any[];
  stringParseAsLong: (arg0: string) => number;
  nbtHasKey: (arg0: Record<string, any>, arg1: string) => boolean;
  itemstackNbt: (arg0: ValueItemstack) => Record<string, any>;
  blockIsOpaque: (arg0: ValueBlock) => boolean;
  entityIsWet: (arg0: ValueEntity) => boolean;
  booleanOr: (arg0: boolean, arg1: boolean) => boolean;
  anyIdentity: (arg0: any) => any;
  fluidstackViscosity: (arg0: ValueFluidstack) => number;
  recipeWithOutput: (arg0: ValueRecipe, arg1: ValueIngredients) => ValueRecipe;
  itemstackIsEqualRaw: (arg0: ValueItemstack, arg1: ValueItemstack) => boolean;
  nbtWithout: (arg0: Record<string, any>, arg1: string) => Record<string, any>;
  anyNotEquals: (arg0: any, arg1: any) => boolean;
  numberSubtract: (arg0: number, arg1: number) => number;
  namedName: (arg0: any) => string;
  entityItemFrameRotation: (arg0: ValueEntity) => number;
  nbtAsByteList: (arg0: Record<string, any>) => any[];
  tagListAsNbt: (arg0: any[]) => Record<string, any>;
  entityItems: (arg0: ValueEntity) => any[];
  recipeOutput: (arg0: ValueRecipe) => ValueIngredients;
  ingredientsWithFluids: (arg0: ValueIngredients, arg1: any[]) => ValueIngredients;
  operatorApply: (arg0: Function, arg1: any) => any;
  numberCompact: (arg0: number) => string;
  intListAsNbt: (arg0: any[]) => Record<string, any>;
  nbtGetCompound: (arg0: Record<string, any>, arg1: string) => Record<string, any>;
  itemstackFluidStack: (arg0: ValueItemstack) => ValueFluidstack;
  entityHeight: (arg0: ValueEntity) => number;
  ingredientsWithInputOutput: (arg0: ValueIngredients, arg1: ValueIngredients) => ValueRecipe;
  uniquely_namedUniqueName: (arg0: any) => string;
  fluidstackDataValue: (arg0: ValueFluidstack, arg1: string) => Record<string, any>;
  blockIsShearable: (arg0: ValueBlock) => boolean;
  doubleDoubleToInteger: (arg0: number) => number;
  itemstackIsEnchanted: (arg0: ValueItemstack) => boolean;
  blockPlantAge: (arg0: ValueBlock) => number;
  stringEndsWith: (arg0: string, arg1: string) => boolean;
  itemstackFeCapacity: (arg0: ValueItemstack) => number;
  itemstackHasInventory: (arg0: ValueItemstack) => boolean;
  numberAdd: (arg0: number, arg1: number) => number;
  operatorFlip: (arg0: Function) => Function;
  recipeWithInput: (arg0: ValueRecipe, arg1: ValueIngredients) => ValueRecipe;
  numberIncrement: (arg0: number) => number;
  itemstackStrength: (arg0: ValueItemstack, arg1: ValueBlock) => number;
  numberFloor: (arg0: number) => number;
  integerBinaryOr: (arg0: number, arg1: number) => number;
  ingredientsItems: (arg0: ValueIngredients) => any[];
  nbtUnion: (arg0: Record<string, any>, arg1: Record<string, any>) => Record<string, any>;
  listUnique: (arg0: any[]) => any[];
  integerBinaryAnd: (arg0: number, arg1: number) => number;
  entityHeldItemOffHand: (arg0: ValueEntity) => ValueItemstack;
  stringJoin: (arg0: string, arg1: any[]) => string;
  numberGreaterThan: (arg0: number, arg1: number) => boolean;
  listGetOrDefault: (arg0: any[], arg1: number, arg2: any) => any;
  blockProperties: (arg0: ValueBlock) => Record<string, any>;
  anyIsNotNull: (arg0: any) => boolean;
  nbtWithLong: (arg0: Record<string, any>, arg1: string, arg2: number) => Record<string, any>;
  itemstackRarity: (arg0: ValueItemstack) => string;
  entityIsEating: (arg0: ValueEntity) => boolean;
  operatorApply0: (arg0: Function) => any;
  nbtAsByte: (arg0: Record<string, any>) => number;
  nbtAsTagList: (arg0: Record<string, any>) => any[];
  booleanNor: (arg0: boolean, arg1: boolean) => boolean;
  operatorApply3: (arg0: Function, arg1: any, arg2: any, arg3: any) => any;
  booleanNot: (arg0: boolean) => boolean;
  doubleSqrt: (arg0: number) => number;
  operatorApply2: (arg0: Function, arg1: any, arg2: any) => any;
  itemstackCanBurn: (arg0: ValueItemstack) => boolean;
  integerRightShift: (arg0: number, arg1: number) => number;
  nbtGetListInt: (arg0: Record<string, any>, arg1: string) => any[];
  entityItemFrameContents: (arg0: ValueEntity) => ValueItemstack;
  listGet: (arg0: any[], arg1: number) => any;
  nbtIsSubset: (arg0: Record<string, any>, arg1: Record<string, any>) => boolean;
  fluidstackBucketEmptySound: (arg0: ValueFluidstack) => string;
  byteListAsNbt: (arg0: any[]) => Record<string, any>;
  stringMatchesRegex: (arg0: string, arg1: string) => boolean;
  numberMax: (arg0: number, arg1: number) => number;
  floatAsNbt: (arg0: number) => Record<string, any>;
  listIsNotEmpty: (arg0: any[]) => boolean;
  fluidstackMod: (arg0: ValueFluidstack) => string;
  stringParseAsInteger: (arg0: string) => number;
  entityIsCrouching: (arg0: ValueEntity) => boolean;
  nbtGetLong: (arg0: Record<string, any>, arg1: string) => number;
  nbtWithString: (arg0: Record<string, any>, arg1: string, arg2: string) => Record<string, any>;
  entityIsInLove: (arg0: ValueEntity) => boolean;
  nbtGetTag: (arg0: Record<string, any>, arg1: string) => Record<string, any>;
  nbtGetString: (arg0: Record<string, any>, arg1: string) => string;
  anyConstant: (arg0: any, arg1: any) => any;
  fluidstackBucket: (arg0: ValueFluidstack) => ValueItemstack;
  anyLazyBuilt: (arg0: any, arg1: Function) => any[];
  blockWithProperties: (arg0: ValueBlock, arg1: Record<string, any>) => ValueBlock;
  numberMultiply: (arg0: number, arg1: number) => number;
  integerUnsignedRightShift: (arg0: number, arg1: number) => number;
  stringOperatorByName: (arg0: string) => Function;
  nbtGetInteger: (arg0: Record<string, any>, arg1: string) => number;
  recipeInput: (arg0: ValueRecipe) => ValueIngredients;
  nbtAsShort: (arg0: Record<string, any>) => number;
  ingredientsWithEnergy: (arg0: ValueIngredients, arg1: number, arg2: number) => ValueIngredients;
  doublePow: (arg0: number, arg1: number) => number;
  blockPossibleProperties: (arg0: ValueBlock) => Record<string, any>;
  nbtGetListLong: (arg0: Record<string, any>, arg1: string) => any[];
  nbtGetBoolean: (arg0: Record<string, any>, arg1: string) => boolean;
  entityTargetEntity: (arg0: ValueEntity) => ValueEntity;
  booleanChoice: (arg0: boolean, arg1: any, arg2: any) => any;
  shortAsNbt: (arg0: number) => Record<string, any>;
  blockPlaceSound: (arg0: ValueBlock) => string;
  fluidstackNbt: (arg0: ValueFluidstack) => Record<string, any>;
  itemstackIsStackable: (arg0: ValueItemstack) => boolean;
  entityHurtSound: (arg0: ValueEntity) => string;
  itemstackTooltip: (arg0: ValueItemstack) => any[];
  fluidstackDensity: (arg0: ValueFluidstack) => number;
  fluidstackFluidVaporizeSound: (arg0: ValueFluidstack) => string;
  fluidstackDataKeys: (arg0: ValueFluidstack) => any[];
  stringStartsWith: (arg0: string, arg1: string) => boolean;
  entityIsChild: (arg0: ValueEntity) => boolean;
  operatorApply_n: (arg0: Function, arg1: any[]) => any;
  blockMod: (arg0: ValueBlock) => string;
  stringContains: (arg0: string, arg1: string) => boolean;
  nbtAsDouble: (arg0: Record<string, any>) => number;
  stringIndexOfRegex: (arg0: string, arg1: string) => number;
  nbtWithByteList: (arg0: Record<string, any>, arg1: string, arg2: any[]) => Record<string, any>;
  entityTargetBlock: (arg0: ValueEntity) => ValueBlock;
  nbtAsFloat: (arg0: Record<string, any>) => number;
  anyEquals: (arg0: any, arg1: any) => boolean;
  entityCanBreedWith: (arg0: ValueEntity, arg1: ValueItemstack) => boolean;
  fluidstackTags: (arg0: ValueFluidstack) => any[];
  longListAsNbt: (arg0: any[]) => Record<string, any>;
  nbtAsLongList: (arg0: Record<string, any>) => any[];
  stringStringError: (arg0: string) => string;
  longAsNbt: (arg0: number) => Record<string, any>;
  stringItemByName: (arg0: string) => ValueItemstack;
  listUniquePredicate: (arg0: any[], arg1: Function) => any[];
  stringSplitOn: (arg0: string, arg1: string) => any[];
  stringContainsRegex: (arg0: string, arg1: string) => boolean;
  itemstackDataKeys: (arg0: ValueItemstack) => any[];
  nbtAsString: (arg0: Record<string, any>) => string;
  stringParseAsBoolean: (arg0: string) => boolean;
  integerSubstring: (arg0: number, arg1: number, arg2: string) => string;
  nbtWithDouble: (arg0: Record<string, any>, arg1: string, arg2: number) => Record<string, any>;
  numberCeil: (arg0: number) => number;
  fluidstackWithData: (arg0: ValueFluidstack, arg1: string, arg2: Record<string, any>) => Record<string, any>;
  fluidstackAmount: (arg0: ValueFluidstack) => number;
  listConcat: (arg0: any[], arg1: any[]) => any[];
  nbtWithTagList: (arg0: Record<string, any>, arg1: string, arg2: any[]) => Record<string, any>;
  stringNbtPathMatchFirst: (arg0: string, arg1: Record<string, any>) => Record<string, any>;
  stringFluidsByTag: (arg0: string) => any[];
  entityNbt: (arg0: ValueEntity) => Record<string, any>;
  itemstackHasNbt: (arg0: ValueItemstack) => boolean;
  listAppend: (arg0: any[], arg1: any) => any[];
  itemstackWithData: (arg0: ValueItemstack, arg1: string, arg2: Record<string, any>) => Record<string, any>;
  byteAsNbt: (arg0: number) => Record<string, any>;
  numberDivide: (arg0: number, arg1: number) => number;
  itemstackIsEqualNonNbt: (arg0: ValueItemstack, arg1: ValueItemstack) => boolean;
  ingredientsEnergies: (arg0: ValueIngredients) => any[];
  ingredientsWithItems: (arg0: ValueIngredients, arg1: any[]) => ValueIngredients;
  anyGreaterThanOrEquals: (arg0: any, arg1: any) => boolean;
  itemstackFluidCapacity: (arg0: ValueItemstack) => number;
  listItemListCount: (arg0: any[], arg1: ValueItemstack) => number;
  itemstackMaxSize: (arg0: ValueItemstack) => number;
  nbtIntersection: (arg0: Record<string, any>, arg1: Record<string, any>) => Record<string, any>;
  fluidstackRarity: (arg0: ValueFluidstack) => string;
  stringReplace: (arg0: string, arg1: string, arg2: string) => string;
  nbtWithShort: (arg0: Record<string, any>, arg1: string, arg2: number) => Record<string, any>;
  longLongToDouble: (arg0: number) => number;
  stringReplaceRegex: (arg0: string, arg1: string, arg2: string) => string;
  stringIndexOf: (arg0: string, arg1: string) => number;
  blockItemStack: (arg0: ValueBlock) => ValueItemstack;
  nbtAsIntList: (arg0: Record<string, any>) => any[];
  stringBlockByName: (arg0: string) => ValueBlock;
  itemstackBlock: (arg0: ValueItemstack) => ValueBlock;
  stringNbtPathMatchAll: (arg0: string, arg1: Record<string, any>) => any[];
  fluidstackLightLevel: (arg0: ValueFluidstack) => number;
  listHead: (arg0: any[]) => any;
  itemstackTags: (arg0: ValueItemstack) => any[];
  doubleAsNbt: (arg0: number) => Record<string, any>;
  entityIsItem: (arg0: ValueEntity) => boolean;
  nbtGetListByte: (arg0: Record<string, any>, arg1: string) => any[];
  entityHasGuiOpen: (arg0: ValueEntity) => boolean;
  listEquals_multiset: (arg0: any[], arg1: any[]) => boolean;
  itemstackInventory: (arg0: ValueItemstack) => any[];
  operatorConjunction: (arg0: Function, arg1: Function) => Function;
  itemstackInventorySize: (arg0: ValueItemstack) => number;
  stringConcat: (arg0: string, arg1: string) => string;
  listContainsPredicate: (arg0: any[], arg1: Function) => boolean;
  itemstackMaxDamage: (arg0: ValueItemstack) => number;
  entityEnergy: (arg0: ValueEntity) => number;
  entityMod: (arg0: ValueEntity) => string;
  ingredientsWithEnergies: (arg0: ValueIngredients, arg1: any[]) => ValueIngredients;
  stringRegexScan: (arg0: string, arg1: number, arg2: string) => any[];
  integerIntegerToDouble: (arg0: number) => number;
  entityAge: (arg0: ValueEntity) => number;
  listSlice: (arg0: any[], arg1: number, arg2: number) => any[];
  entityInventory: (arg0: ValueEntity) => any[];
  stringRegexGroup: (arg0: string, arg1: number, arg2: string) => string;
  nbtGetDouble: (arg0: Record<string, any>, arg1: string) => number;
  integerXor: (arg0: number, arg1: number) => number;
  stringBlocksByTag: (arg0: string) => any[];
  itemstackWithSize: (arg0: ValueItemstack, arg1: number) => ValueItemstack;
  nbtSize: (arg0: Record<string, any>) => number;
  entityIsShearable: (arg0: ValueEntity) => boolean;
  itemstackRepairCost: (arg0: ValueItemstack) => number;
  blockStepSound: (arg0: ValueBlock) => string;
  listLength: (arg0: any[]) => number;
  itemstackFeStored: (arg0: ValueItemstack) => number;
  itemstackIsDamageable: (arg0: ValueItemstack) => boolean;
  itemstackIsEnchantable: (arg0: ValueItemstack) => boolean;
  operatorFilter: (arg0: Function, arg1: any[]) => any[];
  operatorReduce1: (arg0: Function, arg1: any[]) => any;
  stringNbtPathTest: (arg0: string, arg1: Record<string, any>) => boolean;
  ingredientsFluids: (arg0: ValueIngredients) => any[];
  nbtAsBoolean: (arg0: Record<string, any>) => boolean;
  entityCanBreed: (arg0: ValueEntity) => boolean;
  fluidstackBlock: (arg0: ValueFluidstack) => ValueBlock;
  nbtKeys: (arg0: Record<string, any>) => any[];
  numberDecrement: (arg0: number) => number;
  booleanAnd: (arg0: boolean, arg1: boolean) => boolean;
}

export interface ValueItemstack {
  id_item: Record<string, any>;

  isEqualNonNbt: (arg0: ValueItemstack) => boolean;
  isEqualRaw: (arg0: ValueItemstack) => boolean;
  damage: () => number;
  nbt: () => Record<string, any>;
  hasNbt: () => boolean;
  mod: () => string;
  canBurn: () => boolean;
  strength: (arg0: ValueBlock) => number;
  feStored: () => number;
  maxDamage: () => number;
  tooltip: () => any[];
  maxSize: () => number;
  withSize: (arg0: number) => ValueItemstack;
  feCapacity: () => number;
  inventory: () => any[];
  isNbtEqual: (arg0: ValueItemstack) => boolean;
  burnTime: () => number;
  isStackable: () => boolean;
  isEnchantable: () => boolean;
  block: () => ValueBlock;
  dataKeys: () => any[];
  canHarvest: (arg0: ValueBlock) => boolean;
  isEnchanted: () => boolean;
  dataValue: (arg0: string) => Record<string, any>;
  inventorySize: () => number;
  tags: () => any[];
  hasInventory: () => boolean;
  fluidCapacity: () => number;
  size: () => number;
  isDamageable: () => boolean;
  withData: (arg0: string, arg1: Record<string, any>) => Record<string, any>;
  fluidStack: () => ValueFluidstack;
  isFeContainer: () => boolean;
  isFluidStack: () => boolean;
  repairCost: () => number;
  rarity: () => string;
}

export interface ValueBlock {
  id_block: Record<string, any>;

  itemStack: () => ValueItemstack;
  placeSound: () => string;
  mod: () => string;
  stepSound: () => string;
  withProperties: (arg0: Record<string, any>) => ValueBlock;
  isOpaque: () => boolean;
  isShearable: () => boolean;
  breakSound: () => string;
  possibleProperties: () => Record<string, any>;
  plantAge: () => number;
  properties: () => Record<string, any>;
  tags: () => any[];
}

export interface ValueIngredients {
  id_ingredients: Record<string, any>;

  withItem: (arg0: number, arg1: ValueItemstack) => ValueIngredients;
  energies: () => any[];
  withFluid: (arg0: number, arg1: ValueFluidstack) => ValueIngredients;
  withEnergies: (arg0: any[]) => ValueIngredients;
  withItems: (arg0: any[]) => ValueIngredients;
  items: () => any[];
  withInputOutput: (arg0: ValueIngredients) => ValueRecipe;
  withFluids: (arg0: any[]) => ValueIngredients;
  fluids: () => any[];
  withEnergy: (arg0: number, arg1: number) => ValueIngredients;
}

export interface ValueRecipe {
  id_recipe: Record<string, any>;

  output: () => ValueIngredients;
  input: () => ValueIngredients;
  withInput: (arg0: ValueIngredients) => ValueRecipe;
  withOutput: (arg0: ValueIngredients) => ValueRecipe;
}

export interface ValueFluidstack {
  id_fluid: Record<string, any>;

  dataKeys: () => any[];
  nbt: () => Record<string, any>;
  amount: () => number;
  fluidVaporizeSound: () => string;
  mod: () => string;
  density: () => number;
  isLighterThanAir: () => boolean;
  dataValue: (arg0: string) => Record<string, any>;
  bucketEmptySound: () => string;
  bucketFillSound: () => string;
  tags: () => any[];
  bucket: () => ValueItemstack;
  lightLevel: () => number;
  viscosity: () => number;
  withData: (arg0: string, arg1: Record<string, any>) => Record<string, any>;
  temperature: () => number;
  block: () => ValueBlock;
  isRawEqual: (arg0: ValueFluidstack) => boolean;
  withAmount: (arg0: number) => ValueFluidstack;
  rarity: () => string;
}

export interface ValueEntity {
  id_entity: Record<string, any>;

  isPlayer: () => boolean;
  nbt: () => Record<string, any>;
  entityItemTooltip: (arg0: ValueItemstack) => any[];
  mod: () => string;
  targetEntity: () => ValueEntity;
  isMinecart: () => boolean;
  isCrouching: () => boolean;
  isEating: () => boolean;
  canBreedWith: (arg0: ValueItemstack) => boolean;
  isMob: () => boolean;
  inventory: () => any[];
  type: () => string;
  isInLove: () => boolean;
  energyCapacity: () => number;
  entityIsBurning: () => boolean;
  heldItem: () => ValueItemstack;
  canBreed: () => boolean;
  isChild: () => boolean;
  height: () => number;
  targetBlock: () => ValueBlock;
  fluids: () => any[];
  energy: () => number;
  isWet: () => boolean;
  item: () => ValueItemstack;
  health: () => number;
  deathSound: () => string;
  itemFrameRotation: () => number;
  mounted: () => any[];
  heldItemOffHand: () => ValueItemstack;
  hasGuiOpen: () => boolean;
  isAnimal: () => boolean;
  hurtSound: () => string;
  isShearable: () => boolean;
  width: () => number;
  armorInventory: () => any[];
  isItem: () => boolean;
  items: () => any[];
  itemFrameContents: () => ValueItemstack;
  age: () => number;
}

